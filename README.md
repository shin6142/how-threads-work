## プロセス
 - プロセス
   - プログラムが起動されると、OSがプロセスを生成する
   - プロセスはプログラムに必要な様々な**リソース**を管理する
     - コードセグメント（実行可能なコード）
     - データセグメント（グローバル変数や静的変数）
     - ヒープ（動的メモリ割り当て）
     - スタック（ローカル変数、関数パラメータ、関数呼び出し）
     - レジスタ（CPU の高速な一時的データ格納場所）
   - 1プロセスにつき、独立したメモリアドレス空間を確保することで、プロセスが他のプロセスのメモリを参照することを防いでいる。
        
        <img width="2240" height="808" alt="image" src="https://github.com/user-attachments/assets/8231bb28-901b-4afe-bc20-9dec2c76a75f" />
   
## スレッド
<img width="2240" height="1216" alt="image" src="https://github.com/user-attachments/assets/b5c15c1b-4a3e-4225-9c70-62c99635934b" />    
<img width="2240" height="1221" alt="image" src="https://github.com/user-attachments/assets/9bdceaf3-b7fb-4b43-a172-bdd3868eb485" />

- スレッドとは、プロセス内の実行単位
- マルチスレッドプロセスでは、複数のスレッドが同時に動作することができます
- 各スレッドは、独自のレジスタとスタックを持っています。
- コードセグメント、データセグメント、ヒープなどの他のリソースは、スレッド間で共有されます。スレッドは、同じプロセス内の他のスレッドと同じメモリアドレス空間を共有しているため、スレッド間の通信は非常に効率的です。しかし、これは同時に1つのスレッドがプロセス全体を破損させる可能性があることを意味します。

## シングルスレッドvsマルチスレッド
- このリポジトリのapp.pyでflaskサーバーを起動し、test.shで負荷テストを実施して処理の完了時間を計測すると、マルチスレッドでのサーバー起動時の方が処理が早く完了することがわかります。また負荷試験実行中の消費メモリを確認すると、マルチスレッドの方がはるかに大きいことがわかります。

## スレッドプール (Thread Pool)
    
**スレッドプール**とは、あらかじめ**作成しておいたスレッドの集合（プール）**であり、プログラムがタスクを実行する際に、このプールからスレッドを再利用する仕組みのことです。

### 1. スレッドプールの目的と必要性

スレッドは並行処理を実現するのに便利ですが、スレッドの**生成（作成）と破棄（終了）にはコスト（オーバーヘッド）**がかかります。特に、短いタスクを大量に処理する場合、タスクごとに新しいスレッドを作成・破棄すると、**スレッドの管理コストがタスクの実行コストを上回る**ことがあり、全体のパフォーマンスが低下します。

スレッドプールは、このオーバーヘッドを解消するために導入されます。

- **オーバーヘッドの削減:** スレッドを使い回すことで、生成・破棄のコストを削減します。
- **リソースの制御:** 同時に実行されるスレッドの最大数を制限することで、システムリソース（メモリやCPU）の過剰な消費を防ぎ、システム全体の安定性を保ちます。
- **レスポンスの向上:** タスクが発生した際に、すぐにプール内の既存スレッドがタスクを開始できるため、レスポンスが向上します。

### 2. スレッドプールの基本的な動作

スレッドプールは、主に以下の要素で構成され、動作します。

1. **スレッドの集合（プール）:** あらかじめ決められた数の**ワーカー・スレッド** (Worker Threads) が作成され、待機状態（アイドル状態）でプールに保持されます。
2. **タスクキュー (Task Queue):** 実行を待っているタスク（仕事）を格納するための待ち行列です。
3. **ディスパッチャ（管理者）:** 新しいタスクが到着すると、ディスパッチャが以下の処理を行います。
    - プール内でアイドル状態のスレッドがいれば、そのスレッドにタスクを割り当てて実行させます。
    - アイドルなスレッドがいなければ、タスクを**タスクキュー**に追加し、スレッドが空くのを待ちます。
    - タスクの実行が完了したスレッドは、破棄されずにプールに戻り、次のタスクを待機（アイドル状態に戻る）します。

### 3. 主なメリットとデメリット

| 項目 | メリット (Advantages) | デメリット (Disadvantages) |
| --- | --- | --- |
| **パフォーマンス** | スレッドの生成・破棄コストを削減し、**全体の実行効率が向上**します。 | タスクの実行時間が**不均一**な場合、短いタスクが長いタスクの後ろで長く待たされる**スタベーション** (Starvation) が発生する可能性があります。 |
| **リソース管理** | 同時実行スレッド数を制限することで、**システムリソースの過負荷を防ぎます**。 | プールのサイズを適切に設定しないと、性能が最大化されません。サイズ設定には、CPUコア数やタスクの性質を考慮する必要があります。 |
| **安定性** | 過剰なスレッド生成による**メモリ不足（OOM: Out Of Memory）を防げます**。 | スレッド間で共有リソースを扱うため、**スレッドセーフ**な設計が必須となります（並行処理の一般的な課題）。 |

## 参考
- https://zenn.dev/farstep/articles/process-thread-difference
